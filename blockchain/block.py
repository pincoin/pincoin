import json
import logging
from datetime import datetime
from hashlib import sha256


class Block:
    logger = logging.getLogger(__name__)

    def __init__(self, index, previous_block_hash, data, difficulty, nonce, timestamp=None):
        """ Constructor for a block

        :param index: block index counter
        :param previous_block_hash: previous block hash to mingle with current block data, timestamp and index
        :param data: block data in JSON format (ie. transactions)
        :param difficulty:
        :param nonce:
        :param timestamp: timestamp when block is created
        """

        self.index = index
        self.previous_block_hash = previous_block_hash
        self.data = json.dumps(data)

        self.difficulty = difficulty
        self.nonce = nonce

        self.timestamp = timestamp if timestamp else datetime.now().timestamp()
        self.hash = self.create_hash()

    def __eq__(self, other):
        return self.index == other.index \
               and self.previous_block_hash == other.previous_block_hash \
               and self.data == other.data \
               and self.difficulty == other.difficulty \
               and self.nonce == other.nonce \
               and self.timestamp == other.timestamp

    def __ne__(self, other):
        return not (self.index == other.index
                    and self.previous_block_hash == other.previous_block_hash
                    and self.data == other.data
                    and self.difficulty == other.difficulty
                    and self.nonce == other.nonce
                    and self.timestamp == other.timestamp)

    def create_hash(self):
        """ Generate fingerprint of current block by mangling previous block hash

        :return: block hash
        """
        block_contents = str(self.index) \
                         + str(self.previous_block_hash) \
                         + str(self.timestamp) \
                         + self.data
        block_hash = sha256(block_contents.encode())
        return block_hash.hexdigest()

    def validate(self, last_block):
        """ Others may add a block, check if valid

        :param last_block: previous block
        :return: True if valid, False otherwise
        """

        if not (isinstance(self.index, int)
                and isinstance(self.hash, str)
                and isinstance(self.previous_block_hash, str)
                and isinstance(self.timestamp, float)
                and isinstance(self.data, str)):
            self.logger.error('invalid block: block structure is broken.')
            return False
        elif last_block.index + 1 != self.index:
            self.logger.error('invalid block: new block index is not consecutive.')
            return False
        elif last_block.hash != self.previous_block_hash:
            self.logger.error('invalid block: last block hash does not match previous block hash in new block.')
            return False
        elif last_block.hash != last_block.create_hash():
            self.logger.error('invalid block: last block hash does not match hash generated by last block.')
            return False
        elif self.hash != self.create_hash():
            self.logger.error('invalid block: new block hash does not match hash generated by new block.')
            return False

        return True
